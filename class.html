<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Python 类 - PyO3 user guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="PyO3 user guide">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/tabs-52f01167.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-78070eb0.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-c528a6fa.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">PyO3 user guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/PyO3/pyo3/tree/main/guide" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>
                        <a href="https://github.com/PyO3/pyo3/edit/main/guide/src/class.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <span class=fa-svg id="git-edit-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M421.7 220.3l-11.3 11.3-22.6 22.6-205 205c-6.6 6.6-14.8 11.5-23.8 14.1L30.8 511c-8.4 2.5-17.5 .2-23.7-6.1S-1.5 489.7 1 481.2L38.7 353.1c2.6-9 7.5-17.2 14.1-23.8l205-205 22.6-22.6 11.3-11.3 33.9 33.9 62.1 62.1 33.9 33.9zM96 353.9l-9.3 9.3c-.9 .9-1.6 2.1-2 3.4l-25.3 86 86-25.3c1.3-.4 2.5-1.1 3.4-2l9.3-9.3H112c-8.8 0-16-7.2-16-16V353.9zM453.3 19.3l39.4 39.4c25 25 25 65.5 0 90.5l-14.5 14.5-22.6 22.6-11.3 11.3-33.9-33.9-62.1-62.1L314.3 67.7l11.3-11.3 22.6-22.6 14.5-14.5c25-25 65.5-25 90.5 0z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="python-类"><a class="header" href="#python-类">Python 类</a></h1>
<p>PyO3 利用 Rust 的过程宏系统提供了一组属性，用于将 Rust 结构体定义为 Python 类。</p>
<p>主要的属性是 <code>#[pyclass]</code>，它用于标注 Rust 的 <code>struct</code> 或 <code>enum</code>，以生成对应的 Python 类型。它们通常还会有一个（或多个，如果启用了 [<code>multiple-pymethods</code>] 特性）用 <code>#[pymethods]</code> 标注的 <code>impl</code> 块，用于定义生成的 Python 类型的方法和常量。<code>#[pymethods]</code> 中也可以实现 Python 的魔术方法，例如 <code>__str__</code>。</p>
<p>本章将讨论这些属性提供的功能和配置。以下是本章各部分内容的链接列表：</p>
<ul>
<li><a href="#defining-a-new-class"><code>#[pyclass]</code></a>
<ul>
<li><a href="#object-properties-using-pyo3get-set"><code>#[pyo3(get, set)]</code></a></li>
</ul>
</li>
<li><a href="#instance-methods"><code>#[pymethods]</code></a>
<ul>
<li><a href="#constructor"><code>#[new]</code></a></li>
<li><a href="#object-properties-using-getter-and-setter"><code>#[getter]</code></a></li>
<li><a href="#object-properties-using-getter-and-setter"><code>#[setter]</code></a></li>
<li><a href="#static-methods"><code>#[staticmethod]</code></a></li>
<li><a href="#class-methods"><code>#[classmethod]</code></a></li>
<li><a href="#class-attributes"><code>#[classattr]</code></a></li>
<li><a href="#method-arguments"><code>#[args]</code></a></li>
</ul>
</li>
<li><a href="class/protocols.html">魔术方法和槽位</a></li>
<li><a href="#classes-as-function-arguments">类作为函数参数</a></li>
</ul>
<h2 id="定义新类"><a class="header" href="#定义新类">定义新类</a></h2>
<p>要定义自定义的 Python 类，可将 <code>#[pyclass]</code> 属性添加到 Rust 结构体或枚举上。</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;

#[pyclass]
struct MyClass {
    inner: i32,
}

// “元组”结构体
#[pyclass]
struct Number(i32);

// PyO3 支持仅含单元变体的枚举（即所有变体都是单元类型）
// 这类简单枚举的行为类似于 Python 的枚举（enum.Enum）
#[pyclass(eq, eq_int)]
#[derive(PartialEq)]
enum MyEnum {
    Variant,
    OtherVariant = 30, // PyO3 支持自定义判别值
}

// PyO3 支持在仅含单元变体的枚举中使用自定义判别值
#[pyclass(eq, eq_int)]
#[derive(PartialEq)]
enum HttpResponse {
    Ok = 200,
    NotFound = 404,
    Teapot = 418,
    // ...
}

// PyO3 也支持包含结构体和元组变体的枚举
// 这些复杂的枚举与上面的简单枚举行为略有不同
// 它们主要用于实例检查和匹配语句模式
// 变体可以混合使用
// 结构体变体具有命名字段，而元组变体会按顺序生成通用字段名 _0, _1, _2, ...
// 除此之外，这两类在功能上是相同的
#[pyclass]
enum Shape {
    Circle { radius: f64 },
    Rectangle { width: f64, height: f64 },
    RegularPolygon(u32, f64),
    Nothing(),
}</code></pre>
<p>上述示例为 <code>MyClass</code>、<code>Number</code>、<code>MyEnum</code>、<code>HttpResponse</code> 和 <code>Shape</code> 生成了 [<code>PyTypeInfo</code>] 和 [<code>PyClass</code>] 的实现。有关生成代码的详细信息，请参见本章末尾的<a href="#implementation-details">实现细节</a>。</p>
<h3 id="限制"><a class="header" href="#限制">限制</a></h3>
<p>为了将 Rust 类型与 Python 集成，PyO3 需要对可使用 <code>#[pyclass]</code> 标注的类型施加一些限制。特别是，这些类型不能有生命周期参数、不能有泛型参数，并且必须是线程安全的。各限制的原因如下所述。</p>
<h4 id="无生命周期参数"><a class="header" href="#无生命周期参数">无生命周期参数</a></h4>
<p>Rust 的生命周期是 Rust 编译器用来分析程序内存安全的机制，它仅在编译时存在；在运行时无法通过 Python 这样的动态语言访问 Rust 的生命周期。</p>
<p>一旦 Rust 数据暴露给 Python，就无法保证 Rust 编译器对数据生命周期的推断仍然成立。Python 是引用计数语言，其引用可能被任意长时间持有，这超出了 Rust 编译器的追踪能力。唯一能正确表达这一点的方式是要求所有 <code>#[pyclass]</code> 类型不借用任何短于 <code>'static</code> 生命周期的数据，即 <code>#[pyclass]</code> 类型不能有任何生命周期参数。</p>
<p>当你需要在 Python 和 Rust 之间共享数据所有权时，应考虑使用引用计数的智能指针（如 [<code>Arc</code>] 或 [<code>Py</code>][<code>Py&lt;T&gt;</code>]），而非带生命周期的借用引用。</p>
<h4 id="无泛型参数"><a class="header" href="#无泛型参数">无泛型参数</a></h4>
<p>带泛型参数 <code>T</code> 的 Rust 结构体 <code>Foo&lt;T&gt;</code> 在每次使用不同的具体类型作为 <code>T</code> 时，都会由编译器生成新的实现。这些实现是按需在使用位置生成的。这与将 <code>Foo</code> 封装为 Python 类型不兼容，因为后者需要一个单一的、编译好的 <code>Foo</code> 实现与 Python 解释器集成。</p>
<p>目前最好的替代方案是编写一个宏，在你需要的每个实例化时展开为一个新的 <code>#[pyclass]</code>：</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;

struct GenericClass&lt;T&gt; {
    data: T,
}

macro_rules! create_interface {
    ($name: ident, $type: ident) =&gt; {
        #[pyclass]
        pub struct $name {
            inner: GenericClass&lt;$type&gt;,
        }
        #[pymethods]
        impl $name {
            #[new]
            pub fn new(data: $type) -&gt; Self {
                Self {
                    inner: GenericClass { data: data },
                }
            }
        }
    };
}

create_interface!(IntClass, i64);
create_interface!(FloatClass, String);</code></pre>
<h4 id="必须是线程安全的"><a class="header" href="#必须是线程安全的">必须是线程安全的</a></h4>
<p>Python 解释器会在线程间自由共享 Python 对象。这意味着：</p>
<ul>
<li>Python 对象可能由不同的 Python 线程创建和销毁，因此 <code>#[pyclass]</code> 类型必须是 <code>Send</code> 的。</li>
<li>Python 对象可能被多个 Python 线程同时访问，因此 <code>#[pyclass]</code> 类型必须是 <code>Sync</code> 的。</li>
</ul>
<p>目前无需过于担心这些要求，简单的类通常已经是线程安全的。本指南稍后会有<a href="./class/thread-safety.html">关于线程安全的详细讨论</a>。</p>
<h2 id="构造器"><a class="header" href="#构造器">构造器</a></h2>
<p>默认情况下，无法从 Python 代码创建自定义类的实例。要声明构造器，需要定义一个方法并用 <code>#[new]</code> 属性标注。只能指定 Python 的 <code>__new__</code> 方法，<code>__init__</code> 不可用。</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymethods]
impl Number {
    #[new]
    fn new(value: i32) -&gt; Self {
        Number(value)
    }
}</code></pre>
<p>或者，如果你的 <code>new</code> 方法可能失败，可以返回 <code>PyResult&lt;Self&gt;</code>。</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::exceptions::PyValueError;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Nonzero(i32);
</span><span class="boring">
</span>#[pymethods]
impl Nonzero {
    #[new]
    fn py_new(value: i32) -&gt; PyResult&lt;Self&gt; {
        if value == 0 {
            Err(PyValueError::new_err("cannot be zero"))
        } else {
            Ok(Nonzero(value))
        }
    }
}</code></pre>
<p>如果你希望返回一个已存在的对象（例如，你的 <code>new</code> 方法缓存了返回值），<code>new</code> 方法可以返回 <code>pyo3::Py&lt;Self&gt;</code>。</p>
<p>如你所见，Rust 方法的名称在这里并不重要；你仍可使用 <code>new()</code> 作为 Rust 层级的构造器。</p>
<p>如果没有声明标记为 <code>#[new]</code> 的方法，则对象实例只能从 Rust 创建，而不能从 Python 创建。</p>
<p>关于参数的更多信息，请参见下面的<a href="#method-arguments"><code>方法参数</code></a>部分。</p>
<h2 id="将类添加到模块"><a class="header" href="#将类添加到模块">将类添加到模块</a></h2>
<p>下一步是创建 Python 模块并将我们的类添加进去：</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">fn main() {}
</span><span class="boring">#[pyclass]
</span><span class="boring">struct Number(i32);
</span><span class="boring">
</span>#[pymodule]
mod my_module {
    #[pymodule_export]
    use super::Number;
}</code></pre>
<h2 id="bound-与内部可变性"><a class="header" href="#bound-与内部可变性">Bound<t> 与内部可变性</t></a></h2>
<p>将 <code>#[pyclass]</code> 类型 <code>T</code> 转换为 Python 对象并在 Rust 代码中访问它常常是必要的。<code>[</code>Py<t><code>] 和 [</code>Bound&lt;’py, T&gt;`] 智能指针是 PyO3 API 中表示 Python 对象的方式。有关它们的更多细节可参见指南中的<a href="./types.html#pyo3s-smart-pointers">Python 对象</a>部分。</t></p>
<p>大多数 Python 对象不提供独占（<code>&amp;mut</code>）访问（参见<a href="./python-from-rust.html#pythons-memory-model">Python 内存模型章节</a>），但 Rust 结构体包装成的 Python 对象（即 <code>pyclass</code> 类型）通常确实需要 <code>&amp;mut</code> 访问。然而，一旦对象的所有权被交给 Python 解释器，Rust 的借用检查器就无法再对 <code>&amp;mut</code> 引用进行分析。</p>
<p>为了解决这一问题，PyO3 使用类似于 <code>std::cell::RefCell&lt;T&gt;</code> 的机制在运行时进行借用检查。这被称为<a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">内部可变性</a>。</p>
<p>熟悉 <code>RefCell&lt;T&gt;</code> 的用户可以像使用 <code>RefCell&lt;T&gt;</code> 一样使用 <code>Py&lt;T&gt;</code> 和 <code>Bound&lt;'py, T&gt;</code>。</p>
<p>不太熟悉 <code>RefCell&lt;T&gt;</code> 的用户，以下是 Rust 借用规则的回顾：</p>
<ul>
<li>在任意时刻，你只能拥有一个可变引用，或任意数量的不可变引用（但不能同时拥有）。</li>
<li>引用的生命周期绝不能超过其所指向数据的生命周期。</li>
</ul>
<p><code>Py&lt;T&gt;</code> 和 <code>Bound&lt;'py, T&gt;</code> 与 <code>RefCell&lt;T&gt;</code> 一样，通过在运行时跟踪引用来确保这些借用规则。</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    #[pyo3(get)]
    num: i32,
}
Python::attach(|py| {
    let obj = Bound::new(py, MyClass { num: 3 }).unwrap();
    {
        let obj_ref = obj.borrow(); // 获取 PyRef
        assert_eq!(obj_ref.num, 3);
        // 除非所有 PyRefs 都被释放，否则无法获取 PyRefMut
        assert!(obj.try_borrow_mut().is_err());
    }
    {
        let mut obj_mut = obj.borrow_mut(); // 获取 PyRefMut
        obj_mut.num = 5;
        // 在 PyRefMut 被释放前，无法获取任何其他引用
        assert!(obj.try_borrow().is_err());
        assert!(obj.try_borrow_mut().is_err());
    }

    // 你可以将 `Bound` 转换为 Python 对象
    pyo3::py_run!(py, obj, "assert obj.num == 5");
});</code></pre>
<p><code>Bound&lt;'py, T&gt;</code> 受限于 Python 的生命周期 <code>'py</code>。若要使对象拥有更长的生命周期（例如，将其存储在某个结构体中）在 Rust 一侧使用 <code>Py&lt;T&gt;</code>。<code>Py&lt;T&gt;</code> 需要一个 <code>Python&lt;'_&gt;</code> token 才能访问：</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    num: i32,
}


fn return_myclass() -&gt; Py&lt;MyClass&gt; {
    Python::attach(|py| Py::new(py, MyClass { num: 1 }).unwrap())
}


let obj = return_myclass();


Python::attach(move |py| {
    let bound = obj.bind(py); // Py&lt;MyClass&gt;::bind 返回 &amp;Bound&lt;'py, MyClass&gt;
    let obj_ref = bound.borrow(); // 获取 PyRef&lt;T&gt;
    assert_eq!(obj_ref.num, 1);
});</code></pre>
<h3 id="冻结类退出内部可变性"><a class="header" href="#冻结类退出内部可变性">冻结类：退出内部可变性</a></h3>
<p>如上所述，运行时借用检查目前默认启用。但类可以通过声明为 <code>frozen</code> 来选择退出。它仍可通过 <code>RefCell</code> 或 <code>Mutex</code> 等标准 Rust 类型使用内部可变性，但不再受限于 PyO3 提供的实现，可以逐字段选择最合适的策略。</p>
<p>标记为 <code>frozen</code> 且为 <code>Sync</code> 的类（例如使用 <code>Mutex</code> 但不使用 <code>RefCell</code>），可以通过 <code>Bound::get</code> 和 <code>Py::get</code> 方法直接访问，而无需 <code>Python</code> token：</p>
<pre><code class="language-rust">use std::sync::atomic::{AtomicUsize, Ordering};
<span class="boring">use pyo3::prelude::*;
</span>

#[pyclass(frozen)]
struct FrozenCounter {
    value: AtomicUsize,
}


let py_counter: Py&lt;FrozenCounter&gt; = Python::attach(|py| {
    let counter = FrozenCounter {
        value: AtomicUsize::new(0),
    };


    Py::new(py, counter).unwrap()
});


py_counter.get().value.fetch_add(1, Ordering::Relaxed);


Python::attach(move |_py| drop(py_counter));</code></pre>
<p>未来 <code>frozen</code> 类可能会成为默认行为，以引导 PyO3 生态系统更明确地应用内部可变性。最终这应能实现对 PyO3 内部机制的进一步优化，并避免下游代码在不需要时承担内部可变性的开销。</p>
<h2 id="自定义类"><a class="header" href="#自定义类">自定义类</a></h2>
<p><code>#[pyclass]</code> 可以使用以下参数：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><code>constructor</code></td><td style="text-align: left">目前仅允许用于<a href="https://pyo3.rs/latest/class.html#complex-enums">复杂枚举的变体</a>。可用于自定义每个变体的类构造函数。其语法与函数和方法的 <code>signature</code> 属性相同，支持相同的选项。</td></tr>
<tr><td style="text-align: left"><span style="white-space: pre"><code>crate = "some::path"</code></span></td><td style="text-align: left">指定导入 <code>pyo3</code> crate 的路径，如果它不在 <code>::pyo3</code> 范围内。</td></tr>
<tr><td style="text-align: left"><code>dict</code></td><td style="text-align: left">为此类的实例提供一个空的 <code>__dict__</code> 以存储自定义属性。</td></tr>
<tr><td style="text-align: left"><code>eq</code></td><td style="text-align: left">使用底层 Rust 数据类型的 <code>PartialEq</code> 实现 <code>__eq__</code>。</td></tr>
<tr><td style="text-align: left"><code>eq_int</code></td><td style="text-align: left">对简单枚举使用 <code>__int__</code> 实现 <code>__eq__</code>。</td></tr>
<tr><td style="text-align: left"><span style="white-space: pre"><code>extends = BaseType</code></span></td><td style="text-align: left">使用自定义基类。默认为 <a href="https://docs.rs/pyo3/latest/pyo3/types/struct.PyAny.html"><code>PyAny</code></a>。</td></tr>
<tr><td style="text-align: left"><span style="white-space: pre"><code>freelist = N</code></span></td><td style="text-align: left">实现大小为 N 的<a href="https://en.wikipedia.org/wiki/Free_list">空闲列表</a>。对于频繁创建和删除的类型，可提升性能。请对代码进行性能分析以确认是否适用 <code>freelist</code>。</td></tr>
<tr><td style="text-align: left"><code>from_py_object</code></td><td style="text-align: left">为此 pyclass 实现 <code>FromPyObject</code>。要求 pyclass 实现 <code>Clone</code>。</td></tr>
<tr><td style="text-align: left"><span style="white-space: pre"><code>frozen</code></span></td><td style="text-align: left">声明你的 pyclass 是不可变的。在获取对 Rust 结构体的共享引用时可避免借用检查开销，但禁用获取可变引用的能力。</td></tr>
<tr><td style="text-align: left"><code>generic</code></td><td style="text-align: left">根据 <a href="https://peps.python.org/pep-0560/">PEP 560</a> 为类实现运行时参数化。</td></tr>
<tr><td style="text-align: left"><code>get_all</code></td><td style="text-align: left">为 pyclass 的所有字段生成 getter。</td></tr>
<tr><td style="text-align: left"><code>hash</code></td><td style="text-align: left">使用底层 Rust 数据类型的 <code>Hash</code> 实现 <code>__hash__</code>。<em>需要 <code>eq</code> 和 <code>frozen</code></em></td></tr>
<tr><td style="text-align: left"><code>immutable_type</code></td><td style="text-align: left">使类型对象不可变。在启用 <code>abi3</code> 特性时适用于 3.14+，否则适用于 3.10+。</td></tr>
<tr><td style="text-align: left"><code>mapping</code></td><td style="text-align: left">告知 PyO3 该类是 <a href="https://pyo3.rs/latest/class/protocols.html#mapping--sequence-types"><code>Mapping</code></a>，因此将其 C-API 序列槽位留空。</td></tr>
<tr><td style="text-align: left"><span style="white-space: pre"><code>module = "module_name"</code></span></td><td style="text-align: left">Python 代码会认为该类在指定模块中定义。默认为 <code>builtins</code>。</td></tr>
<tr><td style="text-align: left"><span style="white-space: pre"><code>name = "python_name"</code></span></td><td style="text-align: left">设置 Python 看到的类名。默认为 Rust 结构体的名称。</td></tr>
<tr><td style="text-align: left"><code>ord</code></td><td style="text-align: left">使用底层 Rust 数据类型的 <code>PartialOrd</code> 实现 <code>__lt__</code>、<code>__gt__</code>、<code>__le__</code> 和 <code>__ge__</code>。<em>需要 <code>eq</code></em></td></tr>
<tr><td style="text-align: left"><code>rename_all = "renaming_rule"</code></td><td style="text-align: left">对结构体的所有 getter 和 setter，或枚举的所有变体应用重命名规则。可能的值有：“camelCase”、“kebab-case”、“lowercase”、“PascalCase”、“SCREAMING-KEBAB-CASE”、“SCREAMING_SNAKE_CASE”、“snake_case”、“UPPERCASE”。</td></tr>
<tr><td style="text-align: left"><code>sequence</code></td><td style="text-align: left">告知 PyO3 该类是 <a href="https://pyo3.rs/latest/class/protocols.html#mapping--sequence-types"><code>Sequence</code></a>，因此将其 C-API 映射长度槽位留空。</td></tr>
<tr><td style="text-align: left"><code>set_all</code></td><td style="text-align: left">为 pyclass 的所有字段生成 setter。</td></tr>
<tr><td style="text-align: left"><code>skip_from_py_object</code></td><td style="text-align: left">阻止该 PyClass 参与 <code>FromPyObject: PyClass + Clone</code> 的通配实现。这允许自定义 <code>FromPyObject</code> 实现，即使 <code>self</code> 是 <code>Clone</code>。</td></tr>
<tr><td style="text-align: left"><code>str</code></td><td style="text-align: left">使用底层 Rust 数据类型的 <code>Display</code> 实现 <code>__str__</code>，或通过可选格式字符串 <code>str="&lt;format string&gt;"</code> 实现。<em>注意：可选格式字符串仅对结构体有效。<code>name</code> 和 <code>rename_all</code> 不能与可选格式字符串同时使用。更多细节见此 <a href="https://github.com/PyO3/pyo3/pull/4233">PR</a> 的讨论。</em></td></tr>
<tr><td style="text-align: left"><code>subclass</code></td><td style="text-align: left">允许其他 Python 类和 <code>#[pyclass]</code> 继承该类。枚举不能被继承。</td></tr>
<tr><td style="text-align: left"><code>unsendable</code></td><td style="text-align: left">如果你的结构体不是 <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>，则需要此参数。相比使用 <code>unsendable</code>，建议通过例如用 <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a> 替代 <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> 的方式使结构体线程安全。使用 <code>unsendable</code> 会导致类在被其他线程访问时 panic。还需注意，Python 的 GC 是多线程的，虽然非 <code>Send</code> 类在其他线程上不会被遍历来避免未定义行为，但这可能导致内存泄漏。</td></tr>
<tr><td style="text-align: left"><code>weakref</code></td><td style="text-align: left">允许该类被<a href="https://docs.python.org/3/library/weakref.html">弱引用</a>。</td></tr>
</tbody>
</table>
</div>
<p>所有这些参数可以直接传递给 <code>#[pyclass(...)]</code> 注解，也可以作为一或多个独立的 <code>#[pyo3(...)]</code> 注解传入，例如：</p>
<pre><code class="language-rust ignore">// 参数直接提供给 `#[pyclass]` 注解。
#[pyclass(name = "SomeName", subclass)]
struct MyClass {}


// 参数作为单独注解提供。
#[pyclass]
#[pyo3(name = "SomeName", subclass)]
struct MyClass {}</code></pre>
<p>这些参数在本指南的各个部分中均有介绍。</p>
<h3 id="返回类型"><a class="header" href="#返回类型">返回类型</a></h3>
<p>通常，<code>#[new]</code> 方法必须返回 <code>T: Into&lt;PyClassInitializer&lt;Self&gt;&gt;</code> 或 <code>PyResult&lt;T&gt; where T: Into&lt;PyClassInitializer&lt;Self&gt;&gt;</code>。</p>
<p>对于可能失败的构造函数，你也应将返回类型包装在 <code>PyResult</code> 中。请参阅下表以确定构造函数应返回的类型：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th></th><th><strong>不会失败</strong></th><th><strong>可能失败</strong></th></tr>
</thead>
<tbody>
<tr><td><strong>无继承</strong></td><td><code>T</code></td><td><code>PyResult&lt;T&gt;</code></td></tr>
<tr><td><strong>继承(T 继承 U)</strong></td><td><code>(T, U)</code></td><td><code>PyResult&lt;(T, U)&gt;</code></td></tr>
<tr><td><strong>继承(一般情况)</strong></td><td>[<code>PyClassInitializer&lt;T&gt;</code>]</td><td><code>PyResult&lt;PyClassInitializer&lt;T&gt;&gt;</code></td></tr>
</tbody>
</table>
</div>
<h2 id="继承"><a class="header" href="#继承">继承</a></h2>
<p>默认情况下，<code>object</code>（即 <code>PyAny</code>）被用作基类。要覆盖此默认设置，请在 <code>pyclass</code> 中使用 <code>extends</code> 参数并指定基类的完整路径。目前，只能继承用 Rust 定义的类以及 PyO3 提供的内置类型；尚不支持继承用 Python 定义的其他类（<a href="https://github.com/PyO3/pyo3/issues/991">#991</a>）。</p>
<p>为方便起见，<code>(T, U)</code> 实现了 <code>Into&lt;PyClassInitializer&lt;T&gt;&gt;</code>，其中 <code>U</code> 是 <code>T</code> 的基类。但对于更深层次的继承，必须显式返回 <code>PyClassInitializer&lt;T&gt;</code>。</p>
<p>要从子类中获取父类，请在方法中使用 [<code>PyRef</code>] 替代 <code>&amp;self</code>，或使用 [<code>PyRefMut</code>] 替代 <code>&amp;mut self</code>。然后可通过 <code>self_.as_super()</code> 以 <code>&amp;PyRef&lt;Self::BaseClass&gt;</code> 的形式访问父类，或通过 <code>self_.into_super()</code> 以 <code>PyRef&lt;Self::BaseClass&gt;</code> 的形式访问（<code>PyRefMut</code> 情况类似）。为方便起见，也可使用 <code>self_.as_ref()</code> 直接获取 <code>&amp;Self::BaseClass</code>；但此方式无法访问继承层次结构中更上层的基类，要访问那些类需多次链式调用 <code>as_super</code> 或 <code>into_super</code>。</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>

#[pyclass(subclass)]
struct BaseClass {
    val1: usize,
}


#[pymethods]
impl BaseClass {
    #[new]
    fn new() -&gt; Self {
        BaseClass { val1: 10 }
    }


    pub fn method1(&amp;self) -&gt; PyResult&lt;usize&gt; {
        Ok(self.val1)
    }
}


#[pyclass(extends=BaseClass, subclass)]
struct SubClass {
    val2: usize,
}


#[pymethods]
impl SubClass {
    #[new]
    fn new() -&gt; (Self, BaseClass) {
        (SubClass { val2: 15 }, BaseClass::new())
    }


    fn method2(self_: PyRef&lt;'_, Self&gt;) -&gt; PyResult&lt;usize&gt; {
        let super_ = self_.as_super(); // 获取 &amp;PyRef&lt;BaseClass&gt;
        super_.method1().map(|x| x * self_.val2)
    }
}


#[pyclass(extends=SubClass)]
struct SubSubClass {
    val3: usize,
}


#[pymethods]
impl SubSubClass {
    #[new]
    fn new() -&gt; PyClassInitializer&lt;Self&gt; {
        PyClassInitializer::from(SubClass::new()).add_subclass(SubSubClass { val3: 20 })
    }


    fn method3(self_: PyRef&lt;'_, Self&gt;) -&gt; PyResult&lt;usize&gt; {
        let base = self_.as_super().as_super(); // 获取 &amp;PyRef&lt;'_, BaseClass&gt;
        base.method1().map(|x| x * self_.val3)
    }


    fn method4(self_: PyRef&lt;'_, Self&gt;) -&gt; PyResult&lt;usize&gt; {
        let v = self_.val3;
        let super_ = self_.into_super(); // 获取 PyRef&lt;'_, SubClass&gt;
        SubClass::method2(super_).map(|x| x * v)
    }


      fn get_values(self_: PyRef&lt;'_, Self&gt;) -&gt; (usize, usize, usize) {
          let val1 = self_.as_super().as_super().val1;
          let val2 = self_.as_super().val2;
          (val1, val2, self_.val3)
      }


    fn double_values(mut self_: PyRefMut&lt;'_, Self&gt;) {
        self_.as_super().as_super().val1 *= 2;
        self_.as_super().val2 *= 2;
        self_.val3 *= 2;
    }


    #[staticmethod]
    fn factory_method(py: Python&lt;'_&gt;, val: usize) -&gt; PyResult&lt;Py&lt;PyAny&gt;&gt; {
        let base = PyClassInitializer::from(BaseClass::new());
        let sub = base.add_subclass(SubClass { val2: val });
        if val % 2 == 0 {
            Ok(Py::new(py, sub)?.into_any())
        } else {
            let sub_sub = sub.add_subclass(SubSubClass { val3: val });
            Ok(Py::new(py, sub_sub)?.into_any())
        }
    }
}
<span class="boring">Python::attach(|py| {
</span><span class="boring">    let subsub = pyo3::Py::new(py, SubSubClass::new()).unwrap();
</span><span class="boring">    pyo3::py_run!(py, subsub, "assert subsub.method1() == 10");
</span><span class="boring">    pyo3::py_run!(py, subsub, "assert subsub.method2() == 150");
</span><span class="boring">    pyo3::py_run!(py, subsub, "assert subsub.method3() == 200");
</span><span class="boring">    pyo3::py_run!(py, subsub, "assert subsub.method4() == 3000");
</span><span class="boring">    pyo3::py_run!(py, subsub, "assert subsub.get_values() == (10, 15, 20)");
</span><span class="boring">    pyo3::py_run!(py, subsub, "assert subsub.double_values() == None");
</span><span class="boring">    pyo3::py_run!(py, subsub, "assert subsub.get_values() == (20, 30, 40)");
</span><span class="boring">    let subsub = SubSubClass::factory_method(py, 2).unwrap();
</span><span class="boring">    let subsubsub = SubSubClass::factory_method(py, 3).unwrap();
</span><span class="boring">    let cls = py.get_type::&lt;SubSubClass&gt;();
</span><span class="boring">    pyo3::py_run!(py, subsub cls, "assert not isinstance(subsub, cls)");
</span><span class="boring">    pyo3::py_run!(py, subsubsub cls, "assert isinstance(subsubsub, cls)");
</span><span class="boring">});
</span>```你可以继承原生类型，例如 `PyDict`，前提是它们实现了 [`PySizedLayout`]({{#PYO3_DOCS_URL}}/pyo3/type_object/trait.PySizedLayout.html)。当使用 Python 有限 API（即 PyO3 的 `abi3` 功能）构建时，不支持此功能。

要在 Rust 类型及其原生基类之间转换，可以将 `slf` 作为 Python 对象使用。通过 `slf.borrow()` 或 `slf.borrow_mut()` 访问 Rust 字段，通过 `slf.cast::&lt;BaseClass&gt;()` 访问基类。

```rust
<span class="boring">#[cfg(not(Py_LIMITED_API))] {
</span><span class="boring">use pyo3::prelude::*;
</span>use pyo3::types::PyDict;
use std::collections::HashMap;


#[pyclass(extends=PyDict)]
#[derive(Default)]
struct DictWithCounter {
    counter: HashMap&lt;String, usize&gt;,
}


#[pymethods]
impl DictWithCounter {
    #[new]
    fn new() -&gt; Self {
        Self::default()
    }


    fn set(slf: &amp;Bound&lt;'_, Self&gt;, key: String, value: Bound&lt;'_, PyAny&gt;) -&gt; PyResult&lt;()&gt; {
        slf.borrow_mut().counter.entry(key.clone()).or_insert(0);
        let dict = slf.cast::&lt;PyDict&gt;()?;
        dict.set_item(key, value)
    }
}
<span class="boring">Python::attach(|py| {
</span><span class="boring">    let cnt = pyo3::Py::new(py, DictWithCounter::new()).unwrap();
</span><span class="boring">    pyo3::py_run!(py, cnt, "cnt.set('abc', 10); assert cnt['abc'] == 10")
</span><span class="boring">});
</span><span class="boring">}</span></code></pre>
<p>如果 <code>SubClass</code> 没有提供基类的初始化，编译将会失败。</p>
<pre><code class="language-rust compile_fail"><span class="boring">use pyo3::prelude::*;
</span>

#[pyclass]
struct BaseClass {
    val1: usize,
}


#[pyclass(extends=BaseClass)]
struct SubClass {
    val2: usize,
}


#[pymethods]
impl SubClass {
    #[new]
    fn new() -&gt; Self {
        SubClass { val2: 15 }
    }
}</code></pre>
<p>当从 Python 创建新实例时，原生基类的 <code>__new__</code> 构造函数会隐式调用。请确保在 <code>#[new]</code> 方法中接受你需要基类获取的参数，即使这些参数未在函数中使用：</p>
<pre><code class="language-rust"><span class="boring">#[allow(dead_code)]
</span><span class="boring">#[cfg(not(Py_LIMITED_API))] {
</span><span class="boring">use pyo3::prelude::*;
</span>use pyo3::types::PyDict;


#[pyclass(extends=PyDict)]
struct MyDict {
    private: i32,
}


#[pymethods]
impl MyDict {
    #[new]
    #[pyo3(signature = (*args, **kwargs))]
    fn new(args: &amp;Bound&lt;'_, PyAny&gt;, kwargs: Option&lt;&amp;Bound&lt;'_, PyAny&gt;&gt;) -&gt; Self {
        Self { private: 0 }
    }


    // 一些使用 `private` 的自定义方法...
}
<span class="boring">Python::attach(|py| {
</span><span class="boring">    let cls = py.get_type::&lt;MyDict&gt;();
</span><span class="boring">    pyo3::py_run!(py, cls, "cls(a=1, b=2)")
</span><span class="boring">});
</span><span class="boring">}</span></code></pre>
<p>在这里，<code>args</code> 和 <code>kwargs</code> 允许在创建子类实例时传入初始项，例如 <code>MyDict(item_sequence)</code> 或 <code>MyDict(a=1, b=2)</code>。</p>
<h2 id="对象属性"><a class="header" href="#对象属性">对象属性</a></h2>
<p>PyO3 支持两种方式为你的 <code>#[pyclass]</code> 添加属性：</p>
<ul>
<li>对于没有副作用的简单结构体字段，可以在 <code>#[pyclass]</code> 字段定义上直接添加 <code>#[pyo3(get, set)]</code> 属性；</li>
<li>对于需要计算的属性，可以定义 <code>#[getter]</code> 和 <code>#[setter]</code> 方法在 <a href="#instance-methods"><code>#[pymethods]</code></a> 块中。</li>
</ul>
<p>我们将在以下章节分别说明。</p>
<h3 id="使用-pyo3get-set-的对象属性"><a class="header" href="#使用-pyo3get-set-的对象属性">使用 <code>#[pyo3(get, set)]</code> 的对象属性</a></h3>
<p>在只是读写无副作用的成员变量这种简单情况下，你可以使用 <code>pyo3</code> 属性在 <code>#[pyclass]</code> 字段定义中声明 getter 和 setter，例如以下示例：</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[allow(dead_code)]
</span>#[pyclass]
struct MyClass {
    #[pyo3(get, set)]
    num: i32,
}</code></pre>
<p>如上代码将使 <code>num</code> 字段可作为 <code>self.num</code> 这一 Python 属性进行读写。若需以与字段不同的名称暴露该属性，可将该名称与其他选项一同指定，例如 <code>#[pyo3(get, set, name = "custom_name")]</code>。</p>
<p>可以仅使用 <code>#[pyo3(get)]</code> 或 <code>#[pyo3(set)]</code> 分别实现只读或只写属性。</p>
<p>要使用这些注解，字段类型必须实现某些转换 trait：</p>
<ul>
<li>对于 <code>get</code>，字段类型 <code>T</code> 必须实现 <code>&amp;T: IntoPyObject</code> 或 <code>T: IntoPyObject + Clone</code>；</li>
<li>对于 <code>set</code>，字段类型必须实现 <code>FromPyObject</code>。</li>
</ul>
<p>例如，<code>Cell</code> 类型提供了这些 trait 的实现（前提是其内部类型也实现了该 trait）。这意味着你可以在 <code>Cell</code> 包裹的字段上使用 <code>#[pyo3(get, set)]</code>。</p>
<h3 id="使用-getter-和-setter-的对象属性"><a class="header" href="#使用-getter-和-setter-的对象属性">使用 <code>#[getter]</code> 和 <code>#[setter]</code> 的对象属性</a></h3>
<p>对于不满足 <code>#[pyo3(get, set)]</code> trait 要求，或需要副作用的情况，可以在 <code>#[pymethods]</code> 的 <code>impl</code> 块中定义描述符方法。</p>
<p>这通过使用 <code>#[getter]</code> 和 <code>#[setter]</code> 属性实现，如下例所示：</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    num: i32,
}


#[pymethods]
impl MyClass {
    #[getter]
    fn num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }
}</code></pre>
<p>默认情况下，getter 或 setter 的函数名即为属性名。有几种方式可以覆盖该名称。</p>
<p>如果函数名以 <code>get_</code> 或 <code>set_</code> 开头（分别对应 getter 和 setter），则属性名将为去除该前缀后的函数名。这在函数名为 Rust 关键字（如 <code>type</code>）时也很有用（自 Rust 2018 起可使用<a href="https://doc.rust-lang.org/edition-guide/rust-2018/module-system/raw-identifiers.html">原生标识符</a>）。</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[getter]
    fn get_num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }


    #[setter]
    fn set_num(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}</code></pre>
<p>此时会定义名为 <code>num</code> 的属性，并可通过 <code>self.num</code> 从 Python 代码访问。</p>
<p><code>#[getter]</code> 和 <code>#[setter]</code> 属性都接受一个参数。如果指定了该参数，则将其作为属性名，例如：</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">   num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[getter(number)]
    fn num(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(self.num)
    }


    #[setter(number)]
    fn set_num(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}</code></pre>
<p>此时会定义名为 <code>number</code> 的属性，并可通过 <code>self.number</code> 从 Python 代码访问。</p>
<p>由 <code>#[setter]</code> 或 <code>#[pyo3(set)]</code> 定义的属性在 <code>del</code> 操作时总是会引发 <code>AttributeError</code>。自定义 <code>del</code> 行为的支持正在被追踪于 <a href="https://github.com/PyO3/pyo3/issues/1778">#1778</a>。</p>
<h2 id="实例方法"><a class="header" href="#实例方法">实例方法</a></h2>
<p>要定义兼容 Python 的方法，需要在结构体的 <code>impl</code> 块上添加 <code>#[pymethods]</code> 属性。PyO3 会为该块中的所有函数生成兼容 Python 的包装器，包括描述符、类方法、静态方法等变体。</p>
<p>由于 Rust 允许多个 <code>impl</code> 块，你可以轻松地区分对 Python（及 Rust）公开的方法和只对 Rust 公开的方法。但若需要为同一结构体定义多个 <code>#[pymethods]</code> 块，则必须启用 PyO3 的 [<code>multiple-pymethods</code>] 特性。</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    fn method1(&amp;self) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }


    fn set_method(&amp;mut self, value: i32) -&gt; PyResult&lt;()&gt; {
        self.num = value;
        Ok(())
    }
}</code></pre>
<p>可以使用 <code>&amp;self</code> 或 <code>&amp;mut self</code>，这得益于使用了 <a href="#bound-and-interior-mutability">运行时借用检查</a>。</p>
<p>返回类型必须是 <code>PyResult&lt;T&gt;</code> 或 <code>T</code>，其中 <code>T</code> 实现了 <code>IntoPyObject</code>；如果方法不会引发 Python 异常，则允许使用后一种形式。</p>
<p>方法签名中可包含一个 <code>Python</code> 参数，此时方法包装器会注入 <code>py</code> 参数，例如：</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    fn method2(&amp;self, py: Python&lt;'_&gt;) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}</code></pre>
<p>从 Python 视角来看，此例中的 <code>method2</code> 不接受任何参数。</p>
<h2 id="类方法"><a class="header" href="#类方法">类方法</a></h2>
<p>要为自定义类创建类方法，需使用 <code>#[classmethod]</code> 属性标注方法。这等同于 Python 中的 <code>@classmethod</code> 装饰器。</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyType;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    #[allow(dead_code)]
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[classmethod]
    fn cls_method(cls: &amp;Bound&lt;'_, PyType&gt;) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}</code></pre>
<p>这声明了一个可由 Python 调用的类方法。</p>
<ul>
<li>第一个参数是调用该方法的类的类型对象，可能是派生类的类型对象；</li>
<li>第一个参数的类型默认为 <code>&amp;Bound&lt;'_, PyType&gt;</code>；</li>
<li>关于 <code>parameter-list</code> 的细节，请参阅 <code>方法参数</code> 部分文档；</li>
<li>返回类型必须是 <code>PyResult&lt;T&gt;</code> 或 <code>T</code>，其中 <code>T</code> 实现了 <code>IntoPyObject</code>。</li>
</ul>
<h3 id="接受类参数的构造函数"><a class="header" href="#接受类参数的构造函数">接受类参数的构造函数</a></h3>
<p>要创建一个接受位置类参数的构造函数，可以组合使用 <code>#[classmethod]</code> 和 <code>#[new]</code> 修饰符：</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span><span class="boring">use pyo3::types::PyType;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct BaseClass(Py&lt;PyAny&gt;);
</span><span class="boring">
</span>#[pymethods]
impl BaseClass {
    #[new]
    #[classmethod]
    fn py_new(cls: &amp;Bound&lt;'_, PyType&gt;) -&gt; PyResult&lt;Self&gt; {
        // 获取一个（大概）在该类的子类上声明的抽象属性。
        let subclass_attr: Bound&lt;'_, PyAny&gt; = cls.getattr("a_class_attr")?;
        Ok(Self(subclass_attr.unbind()))
    }
}</code></pre>
<h2 id="静态方法"><a class="header" href="#静态方法">静态方法</a></h2>
<p>要为自定义类创建静态方法，需用 <code>#[staticmethod]</code> 属性标注方法。返回类型必须是 <code>T</code> 或 <code>PyResult&lt;T&gt;</code>，其中 <code>T</code> 实现了 <code>IntoPyObject</code>。</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    #[allow(dead_code)]
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[staticmethod]
    fn static_method(param1: i32, param2: &amp;str) -&gt; PyResult&lt;i32&gt; {
        Ok(10)
    }
}
```## 类属性

要创建一个类属性（也称为 [class variable][classattr]），可以将一个无参数的方法标注上 `#[classattr]` 属性。

```rust,no_run
<span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {}
</span>#[pymethods]
impl MyClass {
    #[classattr]
    fn my_attribute() -&gt; String {
        "hello".to_string()
    }
}

Python::attach(|py| {
    let my_class = py.get_type::&lt;MyClass&gt;();
    pyo3::py_run!(py, my_class, "assert my_class.my_attribute == 'hello'")
});</code></pre>
<blockquote>
<p>注意：如果该方法返回类型为 <code>Result</code> 并返回 <code>Err</code>，PyO3 在创建类时会 panic。</p>
</blockquote>
<blockquote>
<p>注意：<code>#[classattr]</code> 不能与 <a href="./function.html#warn"><code>#[pyo3(warn(...))]</code></a> 属性一起使用。</p>
</blockquote>
<p>如果类属性仅由 <code>const</code> 代码定义，则也可以标注关联常量：</p>
<pre><code class="language-rust no_run"><span class="boring">use pyo3::prelude::*;
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {}
</span>#[pymethods]
impl MyClass {
    #[classattr]
    const MY_CONST_ATTRIBUTE: &amp;'static str = "foobar";
}</code></pre>
<h2 id="类作为函数参数"><a class="header" href="#类作为函数参数">类作为函数参数</a></h2>
<p>类对象可以用作 <code>#[pyfunction]</code> 和 <code>#[pymethods]</code> 的参数，方式与实例方法的 self 参数相同，即可以作为以下类型传递：</p>
<ul>
<li>指向类 Python 对象的 <code>Py&lt;T&gt;</code> 或 <code>Bound&lt;'py, T&gt;</code> 智能指针，</li>
<li>指向 Python 对象中包含的 Rust 数据的 <code>&amp;T</code> 或 <code>&amp;mut T</code> 引用，</li>
<li>或 <code>PyRef&lt;T&gt;</code> 和 <code>PyRefMut&lt;T&gt;</code> 引用包装器。</li>
</ul>
<p>以下为每种方式的示例：</p>
<pre><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
struct MyClass {
    my_field: i32,
}

// 当 Python 对象无关紧要时，取 Rust 数据的引用。
#[pyfunction]
fn increment_field(my_class: &amp;mut MyClass) {
    my_class.my_field += 1;
}

// 当借用应自动进行，但仍需要访问 Python 对象时，使用引用包装器。
#[pyfunction]
fn print_field_and_return_me(my_class: PyRef&lt;'_, MyClass&gt;) -&gt; PyRef&lt;'_, MyClass&gt; {
    println!("{}", my_class.my_field);
    my_class
}

// 当需要手动管理借用时，取（或引用）Python 对象的智能指针。
#[pyfunction]
fn increment_then_print_field(my_class: &amp;Bound&lt;'_, MyClass&gt;) {
    my_class.borrow_mut().my_field += 1;

    println!("{}", my_class.borrow().my_field);
}

// 当需要将 Python 对象智能指针存储到其他地方时，优先使用 `Py&lt;T&gt;` 而非 `Bound&lt;'py, T&gt;`，以避免生命周期限制。
#[pyfunction]
fn print_refcnt(my_class: Py&lt;MyClass&gt;, py: Python&lt;'_&gt;) {
    println!("{}", my_class.get_refcnt(py));
}</code></pre>
<p>如果类可以克隆，也可以按值传递，即如果实现了 <code>Clone</code>（例如通过 <code>#[derive(Clone)]</code>），则会自动实现 <code>FromPyObject</code>：</p>
<pre><code class="language-rust no_run"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
#[derive(Clone)]
struct MyClass {
    my_field: Box&lt;i32&gt;,
}

#[pyfunction]
fn disassemble_clone(my_class: MyClass) {
    let MyClass { mut my_field } = my_class;
    *my_field += 1;
}</code></pre>
<p>请注意，对类使用 <code>#[derive(FromPyObject)]</code> 通常没有用，因为它会尝试通过查找任意 Python 对象的属性来填充字段，从而构造一个新的 Rust 值。</p>
<h2 id="方法参数"><a class="header" href="#方法参数">方法参数</a></h2>
<p>与 <code>#[pyfunction]</code> 类似，<code>#[pyo3(signature = (...))]</code> 属性可用于指定 <code>#[pymethods]</code> 接受参数的方式。请查阅 <a href="./function/signature.html"><code>函数签名</code></a> 文档以了解此属性接受的参数。</p>
<p>下面的示例定义了一个类 <code>MyClass</code> 及其方法 <code>method</code>。该方法的签名设置了 <code>num</code> 和 <code>name</code> 的默认值，并指示 <code>py_args</code> 收集所有额外的位置参数，<code>py_kwargs</code> 收集所有额外的关键字参数：</p>
<pre><code class="language-rust no_run"><span class="boring">use pyo3::prelude::*;
</span>use pyo3::types::{PyDict, PyTuple};
<span class="boring">
</span><span class="boring">#[pyclass]
</span><span class="boring">struct MyClass {
</span><span class="boring">    num: i32,
</span><span class="boring">}
</span>#[pymethods]
impl MyClass {
    #[new]
    #[pyo3(signature = (num=-1))]
    fn new(num: i32) -&gt; Self {
        MyClass { num }
    }

    #[pyo3(signature = (num=10, *py_args, name="Hello", **py_kwargs))]
    fn method(
        &amp;mut self,
        num: i32,
        py_args: &amp;Bound&lt;'_, PyTuple&gt;,
        name: &amp;str,
        py_kwargs: Option&lt;&amp;Bound&lt;'_, PyDict&gt;&gt;,
    ) -&gt; String {
        let num_before = self.num;
        self.num = num;
        format!(
            "num={} (was previously={}), py_args={:?}, name={}, py_kwargs={:?} ",
            num, num_before, py_args, name, py_kwargs,
        )
    }
}</code></pre>
<p>在 Python 中，可能这样使用：</p>
<pre><code class="language-python">&gt;&gt;&gt; import mymodule
&gt;&gt;&gt; mc = mymodule.MyClass()
&gt;&gt;&gt; print(mc.method(44, False, "World", 666, x=44, y=55))
py_args=('World', 666), py_kwargs=Some({'x': 44, 'y': 55}), name=Hello, num=44, num_before=-1
&gt;&gt;&gt; print(mc.method(num=-1, name="World"))
py_args=(), py_kwargs=None, name=World, num=-1, num_before=44
</code></pre>
<p><code>#[pyfunction]</code> 的 <a href="./function/signature.html#overriding-the-generated-signature"><code>#[pyo3(text_signature = "...")</code></a> 选项对 <code>#[pymethods]</code> 同样有效。</p>
<pre><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span>use pyo3::prelude::*;
use pyo3::types::PyType;

#[pyclass]
struct MyClass {}

#[pymethods]
impl MyClass {
    #[new]
    #[pyo3(text_signature = "(c, d)")]
    fn new(c: i32, d: &amp;str) -&gt; Self {
        Self {}
    }
    // self 参数应写作 $self
    #[pyo3(text_signature = "($self, e, f)")]
    fn my_method(&amp;self, e: i32, f: i32) -&gt; i32 {
        e + f
    }
    // 类方法参数同理，使用 $cls
    #[classmethod]
    #[pyo3(text_signature = "($cls, e, f)")]
    fn my_class_method(cls: &amp;Bound&lt;'_, PyType&gt;, e: i32, f: i32) -&gt; i32 {
        e + f
    }
    #[staticmethod]
    #[pyo3(text_signature = "(e, f)")]
    fn my_static_method(e: i32, f: i32) -&gt; i32 {
        e + f
    }
}
<span class="boring">
</span><span class="boring">fn main() -&gt; PyResult&lt;()&gt; {
</span><span class="boring">    Python::attach(|py| {
</span><span class="boring">        let inspect = PyModule::import(py, "inspect")?.getattr("signature")?;
</span><span class="boring">        let module = PyModule::new(py, "my_module")?;
</span><span class="boring">        module.add_class::&lt;MyClass&gt;()?;
</span><span class="boring">        let class = module.getattr("MyClass")?;
</span><span class="boring">
</span><span class="boring">        if cfg!(not(Py_LIMITED_API)) || py.version_info() &gt;= (3, 10)  {
</span><span class="boring">            let doc: String = class.getattr("__doc__")?.extract()?;
</span><span class="boring">            assert_eq!(doc, "");
</span><span class="boring">
</span><span class="boring">            let sig: String = inspect
</span><span class="boring">                .call1((&amp;class,))?
</span><span class="boring">                .call_method0("__str__")?
</span><span class="boring">                .extract()?;
</span><span class="boring">            assert_eq!(sig, "(c, d)");
</span><span class="boring">        } else {
</span><span class="boring">            let doc: String = class.getattr("__doc__")?.extract()?;
</span><span class="boring">            assert_eq!(doc, "");
</span><span class="boring">
</span><span class="boring">            inspect.call1((&amp;class,)).expect_err("`text_signature` on classes is not compatible with compilation in `abi3` mode until Python 3.10 or greater");
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let method = class.getattr("my_method")?;
</span><span class="boring">
</span><span class="boring">            assert!(method.getattr("__doc__")?.is_none());
</span><span class="boring">
</span><span class="boring">            let sig: String = inspect
</span><span class="boring">                .call1((method,))?
</span><span class="boring">                .call_method0("__str__")?
</span><span class="boring">                .extract()?;
</span><span class="boring">            assert_eq!(sig, "(self, /, e, f)");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let method = class.getattr("my_class_method")?;
</span><span class="boring">
</span><span class="boring">            assert!(method.getattr("__doc__")?.is_none());
</span><span class="boring">
</span><span class="boring">            let sig: String = inspect
</span><span class="boring">                .call1((method,))?
</span><span class="boring">                .call_method0("__str__")?
</span><span class="boring">                .extract()?;
</span><span class="boring">            assert_eq!(sig, "(e, f)");  // inspect.signature skips the $cls arg
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        {
</span><span class="boring">            let method = class.getattr("my_static_method")?;
</span><span class="boring">
</span><span class="boring">            assert!(method.getattr("__doc__")?.is_none());
</span><span class="boring">
</span><span class="boring">            let sig: String = inspect
</span><span class="boring">                .call1((method,))?
</span><span class="boring">                .call_method0("__str__")?
</span><span class="boring">                .extract()?;
</span><span class="boring">            assert_eq!(sig, "(e, f)");
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    })
</span><span class="boring">}</span></code></pre>
<p>注意：在 <code>#[new]</code> 上使用 <code>text_signature</code> 在 Python 3.10 或更高版本之前，与 <code>abi3</code> 模式下的编译不兼容。</p>
<h3 id="方法接收器与生命周期省略"><a class="header" href="#方法接收器与生命周期省略">方法接收器与生命周期省略</a></h3>
<p>PyO3 支持使用常规方法接收器（共享引用 <code>&amp;self</code> 和独占引用 <code>&amp;mut self</code>）来编写实例方法。这与[生命周期省略][lifetime-elision]交互，即接收器的生命周期会被分配给所有省略了生命周期的输出参数。</p>
<p>这是普通 Rust 代码的一个良好默认行为，因为返回值更可能借用接收器而不是其他参数（如果存在生命周期的话）。然而，在基于 PyO3 的代码中返回绑定引用 <code>Bound&lt;'py, T&gt;</code> 时，Python 生命周期 <code>'py</code> 通常应从作为参数传入的 <code>py: Python&lt;'py&gt;</code> token 导出，而不是从接收器导出。</p>
<p>具体来说，像这样的签名：</p>
<pre><code class="language-rust ignore">fn frobnicate(&amp;self, py: Python) -&gt; Bound&lt;Foo&gt;;</code></pre>
<p>将无法正常工作，因为它被推断为：</p>
<pre><code class="language-rust ignore">fn frobnicate&lt;'a, 'py&gt;(&amp;'a self, py: Python&lt;'py&gt;) -&gt; Bound&lt;'a, Foo&gt;;</code></pre>
<p>而不是预期的：</p>
<pre><code class="language-rust ignore">fn frobnicate&lt;'a, 'py&gt;(&amp;'a self, py: Python&lt;'py&gt;) -&gt; Bound&lt;'py, Foo&gt;;</code></pre>
<p>而应通常写成：</p>
<pre><code class="language-rust ignore">fn frobnicate&lt;'py&gt;(&amp;self, py: Python&lt;'py&gt;) -&gt; Bound&lt;'py, Foo&gt;;</code></pre>
<p><code>#[pyfunction]</code> 不存在此问题，因为接收器生命周期的特殊情况不适用，事实上像这样的签名：</p>
<pre><code class="language-rust ignore">fn frobnicate(bar: &amp;Bar, py: Python) -&gt; Bound&lt;Foo&gt;;</code></pre>
<p>将导致编译器错误 [E0106 “缺少生命周期说明符”][compiler-error-e0106]。</p>
<h2 id="pyclass-枚举"><a class="header" href="#pyclass-枚举"><code>#[pyclass]</code> 枚举</a></h2>
<p>PyO3 中的枚举支持分为两种类型，取决于枚举的变体类型：简单枚举和复杂枚举。</p>
<h3 id="简单枚举"><a class="header" href="#简单枚举">简单枚举</a></h3>
<p>简单枚举（又称 C 风格枚举）仅具有单元变体。</p>
<p>PyO3 为每个变体添加一个类属性，因此你可以在 Python 中直接访问它们而无需定义 <code>#[new]</code>。PyO3 还提供了 <code>__richcmp__</code> 和 <code>__int__</code> 的默认实现，因此可以使用 <code>==</code> 进行比较：</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass(eq, eq_int)]
#[derive(PartialEq)]
enum MyEnum {
    Variant,
    OtherVariant,
}

Python::attach(|py| {
    let x = Py::new(py, MyEnum::Variant).unwrap();
    let y = Py::new(py, MyEnum::OtherVariant).unwrap();
    let cls = py.get_type::&lt;MyEnum&gt;();
    pyo3::py_run!(py, x y cls, r#"
        assert x == cls.Variant
        assert y == cls.OtherVariant
        assert x != y
    "#)
})
```你也可以将简单的枚举转换为 `int`：

```rust
<span class="boring">use pyo3::prelude::*;
</span>#[pyclass(eq, eq_int)]
#[derive(PartialEq)]
enum MyEnum {
    Variant,
    OtherVariant = 10,
}


Python::attach(|py| {
    let cls = py.get_type::&lt;MyEnum&gt;();
    let x = MyEnum::Variant as i32; // 具体的值由编译器分配。
    pyo3::py_run!(py, cls x, r#"
        assert int(cls.Variant) == x
        assert int(cls.OtherVariant) == 10
    "#)
})</code></pre>
<p>PyO3 也为枚举提供了 <code>__repr__</code>：</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass(eq, eq_int)]
#[derive(PartialEq)]
enum MyEnum{
    Variant,
    OtherVariant,
}


Python::attach(|py| {
    let cls = py.get_type::&lt;MyEnum&gt;();
    let x = Py::new(py, MyEnum::Variant).unwrap();
    pyo3::py_run!(py, cls x, r#"
        assert repr(x) == 'MyEnum.Variant'
        assert repr(cls.OtherVariant) == 'MyEnum.OtherVariant'
    "#)
})</code></pre>
<p>PyO3 定义的所有方法都可以被重写。例如，以下是如何重写 <code>__repr__</code> 的示例：</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass(eq, eq_int)]
#[derive(PartialEq)]
enum MyEnum {
    Answer = 42,
}


#[pymethods]
impl MyEnum {
    fn __repr__(&amp;self) -&gt; &amp;'static str {
        "42"
    }
}


Python::attach(|py| {
    let cls = py.get_type::&lt;MyEnum&gt;();
    pyo3::py_run!(py, cls, "assert repr(cls.Answer) == '42'")
})</code></pre>
<p>枚举及其变体也可以使用 <code>#[pyo3(name)]</code> 进行重命名：</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass(eq, eq_int, name = "RenamedEnum")]
#[derive(PartialEq)]
enum MyEnum {
    #[pyo3(name = "UPPERCASE")]
    Variant,
}


Python::attach(|py| {
    let x = Py::new(py, MyEnum::Variant).unwrap();
    let cls = py.get_type::&lt;MyEnum&gt;();
    pyo3::py_run!(py, x cls, r#"
        assert repr(x) == 'RenamedEnum.UPPERCASE'
        assert x == cls.UPPERCASE
    "#)
})</code></pre>
<p>可以使用 <code>#[pyo3(ord)]</code> 可选地添加枚举变体的顺序比较功能。
<em>注意：当使用 <code>ord</code> 参数时，必须实现 <code>PartialOrd</code> trait。如果没有实现，会在编译时产生错误。</em></p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass(eq, ord)]
#[derive(PartialEq, PartialOrd)]
enum MyEnum{
    A,
    B,
    C,
}


Python::attach(|py| {
    let cls = py.get_type::&lt;MyEnum&gt;();
    let a = Py::new(py, MyEnum::A).unwrap();
    let b = Py::new(py, MyEnum::B).unwrap();
    let c = Py::new(py, MyEnum::C).unwrap();
    pyo3::py_run!(py, cls a b c, r#"
        assert (a &lt; b) == True
        assert (c &lt;= b) == False
        assert (c &gt; a) == True
    "#)
})</code></pre>
<p>你不能将枚举用作基类，也不能让枚举继承自其他类。</p>
<pre><code class="language-rust compile_fail"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass(subclass)]
enum BadBase {
    Var1,
}</code></pre>
<pre><code class="language-rust compile_fail"><span class="boring">use pyo3::prelude::*;
</span>

#[pyclass(subclass)]
struct Base;


#[pyclass(extends=Base)]
enum BadSubclass {
    Var1,
}</code></pre>
<p>目前，<code>#[pyclass]</code> 枚举与 Python 中的 <code>IntEnum</code> 不兼容。</p>
<h3 id="复杂枚举"><a class="header" href="#复杂枚举">复杂枚举</a></h3>
<p>如果一个枚举有任何非单元类型（结构体或元组）的变体，则它被视为复杂枚举。</p>
<p>PyO3 在复杂枚举中仅支持结构体和元组变体。目前不支持单元变体（建议使用空元组作为替代）。</p>
<p>PyO3 为每个变体添加一个类属性，可用于构造值以及匹配模式中。PyO3 还为每个变体的所有字段提供 getter 方法。</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
enum Shape {
    Circle { radius: f64 },
    Rectangle { width: f64, height: f64 },
    RegularPolygon(u32, f64),
    Nothing { },
}


<span class="boring">#[cfg(Py_3_10)]
</span>Python::attach(|py| {
    let circle = Shape::Circle { radius: 10.0 }.into_pyobject(py)?;
    let square = Shape::RegularPolygon(4, 10.0).into_pyobject(py)?;
    let cls = py.get_type::&lt;Shape&gt;();
    pyo3::py_run!(py, circle square cls, r#"
        assert isinstance(circle, cls)
        assert isinstance(circle, cls.Circle)
        assert circle.radius == 10.0


        assert isinstance(square, cls)
        assert isinstance(square, cls.RegularPolygon)
        assert square[0] == 4 # 获取 _0 字段
        assert square[1] == 10.0 # 获取 _1 字段


        def count_vertices(cls, shape):
            match shape:
                case cls.Circle():
                    return 0
                case cls.Rectangle():
                    return 4
                case cls.RegularPolygon(n):
                    return n
                case cls.Nothing():
                    return 0


        assert count_vertices(cls, circle) == 0
        assert count_vertices(cls, square) == 4
    "#);
<span class="boring">  Ok::&lt;_, PyErr&gt;(())
</span>})
<span class="boring">.unwrap();</span></code></pre>
<p>警告：<code>Py::new</code> 和 <code>.into_pyobject</code> 当前行为不一致。注意构造出的值 <em>不是</em> 特定变体的实例。因此，建议仅使用 <code>.into_pyobject</code> 来构造值。</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
enum MyEnum {
    Variant { i: i32 },
}


Python::attach(|py| {
    let x = Py::new(py, MyEnum::Variant { i: 42 }).unwrap();
    let cls = py.get_type::&lt;MyEnum&gt;();
    pyo3::py_run!(py, x cls, r#"
        assert isinstance(x, cls)
        assert not isinstance(x, cls.Variant)
    "#)
})</code></pre>
<p>可以使用 <code>#[pyo3(constructor = (...))]</code> 属性来自定义每个生成类的构造函数。其语法与函数和方法上的 <a href="function/signature.html"><code>#[pyo3(signature = (...))]</code></a> 属性相同，并支持相同选项。要应用此属性，只需将其放在 <code>#[pyclass]</code> 复杂枚举的某个变体上，如下所示：</p>
<pre><code class="language-rust"><span class="boring">use pyo3::prelude::*;
</span>#[pyclass]
enum Shape {
    #[pyo3(constructor = (radius=1.0))]
    Circle { radius: f64 },
    #[pyo3(constructor = (*, width, height))]
    Rectangle { width: f64, height: f64 },
    #[pyo3(constructor = (side_count, radius=1.0))]
    RegularPolygon { side_count: u32, radius: f64 },
    Nothing { },
}


<span class="boring">#[cfg(Py_3_10)]
</span>Python::attach(|py| {
    let cls = py.get_type::&lt;Shape&gt;();
    pyo3::py_run!(py, cls, r#"
        circle = cls.Circle()
        assert isinstance(circle, cls)
        assert isinstance(circle, cls.Circle)
        assert circle.radius == 1.0


        square = cls.Rectangle(width = 1, height = 1)
        assert isinstance(square, cls)
        assert isinstance(square, cls.Rectangle)
        assert square.width == 1
        assert square.height == 1


        hexagon = cls.RegularPolygon(6)
        assert isinstance(hexagon, cls)
        assert isinstance(hexagon, cls.RegularPolygon)
        assert hexagon.side_count == 6
        assert hexagon.radius == 1
    "#)
})</code></pre>
<h2 id="实现细节"><a class="header" href="#实现细节">实现细节</a></h2>
<p><code>#[pyclass]</code> 宏依赖于大量的条件代码生成：每个 <code>#[pyclass]</code> 可选择性地拥有一个 <code>#[pymethods]</code> 块。</p>
<p>为了支持这种灵活性，<code>#[pyclass]</code> 宏会展开成一段样板代码，设置 <a href="https://github.com/dtolnay/case-studies/blob/master/autoref-specialization/README.md">“dtolnay 特化”</a> 结构。这种实现模式使 Rust 编译器能够在存在 <code>#[pymethods]</code> 实现时使用它们，而在不存在时回退到默认（空）定义。</p>
<p>这种简单技术适用于零个或一个实现的情况。为了支持一个 <code>#[pyclass]</code> 有多个 <code>#[pymethods]</code>（在 [<code>multiple-pymethods</code>] 功能下），会改用 <code>inventory</code> crate 提供的注册机制。它在库加载时收集 <code>impl</code>，但并非所有平台都支持。详见 <a href="https://github.com/dtolnay/inventory#how-it-works">inventory: 它如何工作</a>。</p>
<p><code>#[pyclass]</code> 宏大致展开为如下代码。<code>PyClassImplCollector</code> 是 PyO3 内部用于 dtolnay 特化的类型：</p>
<pre><code class="language-rust"><span class="boring">#[cfg(not(feature = "multiple-pymethods"))] {
</span><span class="boring">use pyo3::prelude::*;
</span>// 注意：启用 `multiple-pymethods` 功能时实现略有不同。
<span class="boring">#[allow(dead_code)]
</span>struct MyClass {
<span class="boring">    #[allow(dead_code)]
</span>    num: i32,
}


impl pyo3::types::DerefToPyAny for MyClass {}


unsafe impl pyo3::type_object::PyTypeInfo for MyClass {
    const NAME: &amp;'static str = "MyClass";
    const MODULE: ::std::option::Option&lt;&amp;'static str&gt; = ::std::option::Option::None;


    #[inline]
    fn type_object_raw(py: pyo3::Python&lt;'_&gt;) -&gt; *mut pyo3::ffi::PyTypeObject {
        &lt;Self as pyo3::impl_::pyclass::PyClassImpl&gt;::lazy_type_object()
            .get_or_try_init(py)
            .unwrap_or_else(|e| pyo3::impl_::pyclass::type_object_init_failed(
                py,
                e,
                &lt;Self as pyo3::type_object::PyTypeInfo&gt;::NAME
            ))
            .as_type_ptr()
    }
}


impl pyo3::PyClass for MyClass {
    type Frozen = pyo3::pyclass::boolean_struct::False;
}


impl pyo3::impl_::pyclass::PyClassImpl for MyClass {
    const IS_BASETYPE: bool = false;
    const IS_SUBCLASS: bool = false;
    const IS_MAPPING: bool = false;
    const IS_SEQUENCE: bool = false;
    type BaseType = PyAny;
    type ThreadChecker = pyo3::impl_::pyclass::SendablePyClass&lt;MyClass&gt;;
    type PyClassMutability = &lt;&lt;pyo3::PyAny as pyo3::impl_::pyclass::PyClassBaseType&gt;::PyClassMutability as pyo3::impl_::pycell::PyClassMutability&gt;::MutableChild;
    type Dict = pyo3::impl_::pyclass::PyClassDummySlot;
    type WeakRef = pyo3::impl_::pyclass::PyClassDummySlot;
    type BaseNativeType = pyo3::PyAny;


    const RAW_DOC: &amp;'static std::ffi::CStr = pyo3::ffi::c_str!("...");
    const DOC: &amp;'static std::ffi::CStr = pyo3::ffi::c_str!("...");


    fn items_iter() -&gt; pyo3::impl_::pyclass::PyClassItemsIter {
        use pyo3::impl_::pyclass::*;
        let collector = PyClassImplCollector::&lt;MyClass&gt;::new();
        static INTRINSIC_ITEMS: PyClassItems = PyClassItems { slots: &amp;[], methods: &amp;[] };
        PyClassItemsIter::new(&amp;INTRINSIC_ITEMS, collector.py_methods())
    }


    fn lazy_type_object() -&gt; &amp;'static pyo3::impl_::pyclass::LazyTypeObject&lt;MyClass&gt; {
        use pyo3::impl_::pyclass::LazyTypeObject;
        static TYPE_OBJECT: LazyTypeObject&lt;MyClass&gt; = LazyTypeObject::new();
        &amp;TYPE_OBJECT
    }
}


<span class="boring">Python::attach(|py| {
</span><span class="boring">    let cls = py.get_type::&lt;MyClass&gt;();
</span><span class="boring">    pyo3::py_run!(py, cls, "assert cls.__name__ == 'MyClass'")
</span><span class="boring">});
</span><span class="boring">}
</span>```[`PyTypeInfo`]: {{#PYO3_DOCS_URL}}/pyo3/type_object/trait.PyTypeInfo.html

[`Py&lt;T&gt;`]: {{#PYO3_DOCS_URL}}/pyo3/struct.Py.html
[`Bound&lt;'py, T&gt;`]: {{#PYO3_DOCS_URL}}/pyo3/struct.Bound.html
[`PyClass`]: {{#PYO3_DOCS_URL}}/pyo3/pyclass/trait.PyClass.html
[`PyRef`]: {{#PYO3_DOCS_URL}}/pyo3/pycell/struct.PyRef.html
[`PyRefMut`]: {{#PYO3_DOCS_URL}}/pyo3/pycell/struct.PyRefMut.html
[`PyClassInitializer&lt;T&gt;`]: {{#PYO3_DOCS_URL}}/pyo3/pyclass_init/struct.PyClassInitializer.html

[`Arc`]: https://doc.rust-lang.org/std/sync/struct.Arc.html

[classattr]: https://docs.python.org/zh-cn/3/tutorial/classes.html#class-and-instance-variables

[`multiple-pymethods`]: features.md#multiple-pymethods

[lifetime-elision]: https://doc.rust-lang.org/reference/lifetime-elision.html
[compiler-error-e0106]: https://doc.rust-lang.org/error_codes/E0106.html</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="function/error-handling.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="class/protocols.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="function/error-handling.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="class/protocols.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/tabs-6977231d.js"></script>



    </div>
    </body>
</html>
